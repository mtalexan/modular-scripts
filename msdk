MSDK_BASEDIR=${HOME}/msdk_code_repos

#because we want this to change the directory of the invoker, we need to source
#this in the .bashrc and declare it as a shell function
function msdk() {

    # setup our variables that might be set by arg parsing
    local SUBDIR=
    local ERROR_RET=
    local PERFECT_MATCH=
    local MATCH_DIRS=()

    while [ ! -z "$1" ] ; do
        case "$1" in
            "/")
                # a "/" indicates an argument follows that's the subdirectory to navigate to if we
                # change directories
                SUBDIR=$2
                shift
                shift
                ;;
            *)
                # Let the match parsing handle it
                source ${LOCAL_REPOS_DIR}/get_dir_match.incl
                ;;
        esac
    done

    if [ ! -z "$ERROR_RET" ] ; then
        if [ $ERROR_RET -eq 2 ] ; then
            #provided search terms, but nothing matched
            echo 1>&2 "No matches found"
            return 2
        elif [ $ERROR_RET -eq 1 ] ; then
            #badly formatted arguments
            echo 1>&2 "Invalid arguments"
            return 1
        fi
    fi

    local FULL_DIR=

    # Construct the full path to the specific directory if we can
    if [ ${#MATCH_DIRS[@]} -lt 1 ] ; then
        #found no matches, or had no arguments about matches
        if [ -z "$MSDK_ROOT_DIR" ] ; then
            echo 1>&2 'MSDK_ROOT_DIR not set, cannot default to $MSDK_ROOT_DIR'
            return 1
        else
            FULL_DIR=${MSDK_ROOT_DIR}/${SUBDIR}
        fi
    elif [ ! -z "$PERFECT_MATCH" ] ; then
    #only one match for our search terms, or had a perfect match on a non-glob search term
        FULL_DIR=${MSDK_BASEDIR}/${PERFECT_MATCH}/${SUBDIR}
    fi

    #have a full path to a specific directory?
    if [ ! -z "$FULL_DIR" ] ; then
        cd ${FULL_DIR}
    else
        echo 1>&2 "Multiple matches found: "
        echo 1>&2 "-----------------------"
        # print each array entry on its own line
        printf '%s\n' "${MATCH_DIRS[@]}" 1>&2
    fi
}

function _msdk_completions() {
    #list of directories under ${MSDK_BASEDIR}, excluding hidden ones
    if [ ${COMP_CWORD} -eq 1 ] ; then
        if [ -z "${COMP_WORDS[${COMP_CWORD}]}" ] ; then
            # single character completions, see below for multi-character completions
            COMPREPLY+=("/") # directory lookup under the current msdk
            COMPREPLY+=("-") # posix extended regex on matches
            COMPREPLY+=(".") # glob search pattern on matches
        fi

        local MSDK_DIRLIST=$(find ${MSDK_BASEDIR} -maxdepth 1 -mindepth 1 \( -type d -o -type l \) | sed -e "s@${MSDK_BASEDIR}/@@g")
        COMPREPLY+=($(compgen -W "${MSDK_DIRLIST} grep glob" "${COMP_WORDS[${COMP_CWORD}]}"))
        # trying to complete the msdk we're looking for
    elif [ ${COMP_CWORD} -eq 2 ] ; then
        if [ "${COMP_WORDS[1]}" == "/" ] ; then
            #based on current msdk setting, do subdir matching
            if [ -z "$MSDK_ROOT_DIR" ] ; then
                echo ""
                echo 1>&2 'ERROR: MSDK_ROOT_DIR not set, cannot default to $MSDK_ROOT_DIR'
            else
                # strip the msdk directory from the returned completion results
                COMPREPLY+=($(compgen -d -- "${MSDK_ROOT_DIR}/${COMP_WORDS[${COMP_CWORD}]}" | sed -e "s@${MSDK_ROOT_DIR}/@@g"))

                # don't add the space after this completion if it's going to autocomplete because of a single match
                compopt -o nospace -o filenames
            fi
        elif [ "${COMP_WORDS[1]}" == ".." ] || [ "${COMP_WORDS[1]}" == "." ] ; then
            #can't complete globs, return empty
            COMPREPLY=()
        elif [ -z "${COMP_WORDS[${COMP_CWORD}]}" ] ; then
            COMPREPLY+=("/") # directory lookup command
            COMPREPLY+=("") # need to give it a second option so it doesn't always add this completion
        elif [ "${COMP_WORDS[${COMP_CWORD}]}" == "/" ] ; then
            # directory lookup command only, let it complete so the space after the completion gets added too
            COMPREPLY+=("/")
        else
            COMPREPLY=()
        fi
    elif [ ${COMP_CWORD} -eq 3 ] ; then
        if [ "${COMP_WORDS[2]}" == "/" ] ; then
            # do directory completion in msdk set by ${COMP_WORDS[1]}
            # strip the msdk directory from the returned completion results
            COMPREPLY+=($(compgen -d -- "${MSDK_BASEDIR}/${COMP_WORDS[1]}/${COMP_WORDS[${COMP_CWORD}]}" | sed -e "s@${MSDK_BASEDIR}/${COMP_WORDS[1]}/@@g"))

            # don't add the space after this completion if it's going to autocomplete because of a single match
            compopt -o nospace -o filenames
        else
            # can't use subdir lookup on a pattern match, so we can't have a '/' argument now
            COMPREPLY=()
        fi
    else
        COMPREPLY=()
    fi
}

function smsdk() {
    local ERROR_RET=
    local PERFECT_MATCH=
    local MATCH_DIRS=()
    local SCRIPT_DIR=${LOCAL_REPOS_DIR}
    local SCRIPT_NAME=set_msdk.sh

    if [ -u $1 ] ; then
        #strip the MSDK_ROOT_DIR down to the directory under $MSDK_BASEDIR only
        CURRENT_DIR=$(echo $MSDK_ROOT_DIR | sed "s@${MSDK_BASEDIR}/@@g")
        echo "Current: $CURRENT_DIR"
        echo "Available: "
        echo "----------"
        lmsdk
        return 1
    elif [ $1 == "help" ] ; then
        echo "USAGE: (source|.) $0 [(<string> | (grep|-) <regex> | (glob|.) <glob>)]"
        echo
        echo "    Sets the msdk repo instance selected as the one to be used for builds."
        echo "    If multiple matches are found or no arguments are given, the available"
        echo "    options will be listed instead."
        echo
        return 1
    fi

    source ${LOCAL_REPOS_DIR}/get_dir_match.incl

    if [ ! -z "$ERROR_RET" ] ; then
        if [ $ERROR_RET -eq 2 ] ; then
            #provided search terms, but nothing matched
            echo 1>&2 "No matches found!!"
            return 2
        elif [ $ERROR_RET -eq 1 ] ; then
            #badly formatted arguments
            echo 1>&2 "Invalid arguments!"
            return 1
        fi
    fi

    # Didn't get a perfect match to a single directory?
    if [ -z "$PERFECT_MATCH" ] ; then
        echo 1>&2 "Multiple matches found: "
        echo 1>&2 "-----------------------"
        # print each array entry on its own line
        printf '%s\n' "${MATCH_DIRS[@]}" 1>&2
        return 1
    fi

    echo "Setting to ${MSDK_BASEDIR}/${PERFECT_MATCH}"

    # Put the command to correctly setup the selected modularSDK repo path into a separate script
    # so it can be run from the .bashrc at session start and give a consistent session setup

    echo "export MSDK_ROOT_DIR=${MSDK_BASEDIR}/${PERFECT_MATCH}" > $SCRIPT_DIR/$SCRIPT_NAME
    chmod +x $SCRIPT_DIR/$SCRIPT_NAME
    source $SCRIPT_DIR/$SCRIPT_NAME

    # space separated list of sub-directories in $MSDK_ROOT_DIR that need to have all symbolic links
    #directly contained in them removed when changing modularSDK sandboxes
    DIRS_TO_CLEAN=

    for dir in $DIRS_TO_CLEAN ; do
        # make sure the directory exists
        if [ -e ${MSDK_ROOT_DIR}/${dir} ] ; then
            LINKS_TO_CHANGE=$(find ${MSDK_ROOT_DIR}/${dir} -maxdepth 1 -type l)
            # turn it into a space separated list
            LINKS_TO_CHANGE=$( echo $LINKS_TO_CHANGE )
            # make sure there were actually results
            if [[ -n $LINKS_TO_CHANGE ]] ; then
                # remove all the link files
                rm $LINKS_TO_CHANGE
            fi
        fi
    done

    # always move to the new modularSDK
    cd ${MSDK_ROOT_DIR}
}

# shared by lmsdk and smsdk
function _smsdk_completions() {
    #list of directories under ${MSDK_BASEDIR}, excluding hidden ones
    if [ ${COMP_CWORD} -eq 1 ] ; then
        if [ -z "${COMP_WORDS[${COMP_CWORD}]}" ] ; then
            # single character completions, see below for multi-character completions
            COMPREPLY+=("-") # posix extended regex on matches
            COMPREPLY+=(".") # glob search pattern on matches
        fi

        local MSDK_DIRLIST=$(find ${MSDK_BASEDIR} -maxdepth 1 -mindepth 1 \( -type d -o -type l \) | sed -e "s@${MSDK_BASEDIR}/@@g")
        COMPREPLY+=($(compgen -W "${MSDK_DIRLIST} grep glob" "${COMP_WORDS[${COMP_CWORD}]}"))
    else
        # can't complete patterns, and don't have any other possible arguments
        COMPREPLY=()
    fi
}

# runs in subshell with parentheses instead of curlys
function lmsdk() (
    shopt -s nullglob
    shopt -s nocasematch

    if [ -u $1 ] ; then
        ls -1 ${MSDK_BASEDIR}
        return 0
    elif [ $1 == "help" ] ; then
        echo "USAGE: $0 [(<string> | (grep|-) <regex> | (glob|.) <glob>)]"
        echo
        echo "    Lists the possible options for modular repo instances that can be selected"
        echo
        return 1
    fi

    # move to and attempt to match the string as a search in the code directory
    pushd $MSDK_BASEDIR &>/dev/null

    local MATCH_MSDK=()
    # determine whether argument 1 was just a case sensitive string we want to find,
    # or whether it was specifying whether we want to use argument 2 as a glob or
    # grep search
    case "$1" in
        "grep" | "-" )
            MATCH_MSDK=$(ls -d -1 * | grep -e "$2") ;;
        "glob" | "." )
            MATCH_MSDK=$(ls -d ${2})  ;;
        *)
            MATCH_MSDK=$(ls -d *${1}*)
    esac

    # one per line
    printf '%s\n' "${MATCH_MSDK[@]}"

    # return to the original directory now that we're done in the different directory
    popd &>/dev/null
)

complete -F _msdk_completions msdk
complete -F _smsdk_completions smsdk
complete -F _smsdk_completions lmsdk

